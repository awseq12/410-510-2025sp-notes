\documentclass{lecturenotes}

\usepackage[colorlinks,urlcolor=blue]{hyperref}
\usepackage{doi}
\usepackage{xspace}
\usepackage{agda}
\usepackage{fontspec}
\usepackage{enumerate}
\setsansfont{Fira Code}
\usepackage{newunicodechar}
\newunicodechar{âˆ£}{\ensuremath{\mid}}
\newunicodechar{â€²}{\ensuremath{{}^\prime}}
\newunicodechar{Ë¡}{\ensuremath{{}^{\textsf{l}}}}
\newunicodechar{Ê³}{\ensuremath{{}^{\textsf{r}}}}
\newunicodechar{âŠ—}{\ensuremath{\otimes}}
\newunicodechar{âˆ·}{\ensuremath{\mathrel{::}}}

\newcommand{\agdanats}{\textsf{â„•}\xspace}

\newcommand{\nil}{\ensuremath{\textsf{[]}}}
\newcommand{\cons}{\ensuremath{\mathbin{\textsf{::}}}}
\newcommand{\app}{\ensuremath{\mathbin{\textsf{++}}}}

\title{Inductive Data Types}
\coursenumber{CSE 410/510}
\coursename{Programming Language Theory}
\lecturenumber{3}
\semester{Spring 2025}
\professor{Professor Andrew K. Hirsch}

\begin{document}
\maketitle

\begin{code}
module lec03-akh where

import Relation.Binary.PropositionalEquality as Eq
open Eq using (_â‰¡_; cong; sym; refl)
open Eq.â‰¡-Reasoning using (begin_; step-â‰¡-âˆ£; step-â‰¡-âŸ©; _âˆŽ)
open import Data.Nat using (â„•; zero; suc; _+_; _*_; _â‰¤_; sâ‰¤s; zâ‰¤n)
open import Data.Nat.Properties using
  (+-assoc; +-comm; +-identityË¡; +-identityÊ³; *-assoc; *-identityË¡; *-identityÊ³; *-distribÊ³-+)
\end{code}

\section{Booleans and Case Analysis}
\label{sec:bool-case-analys}

\begin{itemize}
\item The \textsf{data} keyword can do more than natural numbers. It can do any OCaml variant.
\item For instance, booleans in Agda are defined as follows:
\begin{code}
data ð”¹ : Set where
  True  : ð”¹
  False : ð”¹
\end{code}
\item We can then define functions over booleans using pattern matching:
\begin{code}
_&&_ : ð”¹ -> ð”¹ -> ð”¹
True && y = y
False && y = False

_||_ : ð”¹ -> ð”¹ -> ð”¹
True || y = True
False || y = y
\end{code}
\item We can also see how flexible Agda's infix declarations are:
\begin{code}
if_then_else_ : âˆ€ {A : Set} -> ð”¹ -> A -> A -> A
if True then y else z = y
if False then y else z = z

andb : ð”¹ -> ð”¹ -> ð”¹
andb x y = if x then y else False

orb : ð”¹ -> ð”¹ -> ð”¹
orb x y = if x then True else y
\end{code}
\item You might ask: ``can we do induction on the booleans?''
  The answer is kind of yes, but it's really boring induction.
  It turns out to be just proof by case analysis.
\begin{code}
bool-ind : âˆ€ (P : ð”¹ -> Set) -> P True -> P False -> âˆ€ (x : ð”¹) -> P x
bool-ind P PT PF True = PT
bool-ind P PT PF False = PF
\end{code}
\item Proofs by cases analysis can be done either through the induction principle or the traditional Agda way:
\begin{code}
and-false : âˆ€ (x : ð”¹) -> x && False â‰¡ False
and-false = bool-ind (\ (x : ð”¹) -> x && False â‰¡ False) refl refl 

or-true : âˆ€ (x : ð”¹) -> x || True â‰¡ True
or-true True = refl
or-true False = refl
\end{code}
\end{itemize}

\section{Lists}
\label{sec:lists}

\begin{itemize}
\item Just as in OCaml, we can have parameterized ADTs. For instance, lists are:
\begin{code}
data List (A : Set) : Set where
  [] : List A
  _âˆ·_ : A -> List A -> List A -- N.B.: âˆ· is _not_ two colons (::)

infixr 5 _âˆ·_

{-# BUILTIN LIST List #-}
\end{code}
\item Here, $A$ is a \emph{parameter} of the list type, just like $\alpha~(\textsf{\textquotesingle{}a})$ would be in OCaml.
\item We can also write this equivalent type:
\begin{code}
data Listâ€² : Set -> Setâ‚ where
  nil : âˆ€ {A : Set} -> Listâ€² A
  cons : âˆ€ {A : Set} -> A -> Listâ€² A -> Listâ€² A
\end{code}
\item Here, instead of having a named parameter, we give a type directly to \textsf{List}.
\item This type is \textsf{Set -> Setâ‚}: given a type $A$, the \textsf{List} constructor returns the type $\textsf{List}~A$.
  \begin{itemize}
  \item Yes, this means that \textsf{List} is a function!
  \item You can ignore the subscript \textsf{1} for now. It's there to make Agda happy.
  \end{itemize}
\item You can create a list by applying constructors, just like in OCaml:
\begin{code}
_ : List â„•
_ = 0 âˆ· 1 âˆ· 2 âˆ· []
\end{code}
\item However, you currently can't use list notation.
  The following tells Agda to allow us to use it:
\begin{code}
pattern [_] z = z âˆ· []
pattern [_,_] y z = y âˆ· z âˆ· []
pattern [_,_,_] x y z = x âˆ· y âˆ· z âˆ· []
pattern [_,_,_,_] w x y z = w âˆ· x âˆ· y âˆ· z âˆ· []
pattern [_,_,_,_,_] v w x y z = v âˆ· w âˆ· x âˆ· y âˆ· z âˆ· []
pattern [_,_,_,_,_,_] u v w x y z = u âˆ· v âˆ· w âˆ· x âˆ· y âˆ· z âˆ· []

_ : List â„•
_ = [ 0 , 1 , 2 ]
\end{code}
\begin{itemize}
\item Note the spaces!
\end{itemize}
\item We can program over lists just like we did numbers.
  Note that we use curly braces for implicit arguments.
\begin{code}
infixr 5 _++_

_++_ : âˆ€ {A : Set} -> List A -> List A -> List A
[] ++ ys = ys
(x âˆ· xs) ++ ys = x âˆ· (xs ++ ys)

reverse : âˆ€ {A : Set} -> List A -> List A
reverse [] = []
reverse (x âˆ· xs) = reverse xs ++ [ x ]

length : âˆ€ {A : Set} -> List A -> â„•
length [] = 0
length (_ âˆ· xs) = suc (length xs)
\end{code}

\item Now, what if we want to prove something about lists?
\item Well, we can use induction! There's an induction template for lists, just like for natural numbers.

  \begin{thm}
    For any $\ell \colon \textsf{List}~A$, $P(\ell)$.
  \end{thm}
  \begin{proof}
    We proceed by induction on $\ell$.
    $$P(\ell) = P(\ell)$$

    \noindent\textbf{Base case ($\ell = \nil$):} \dots

    \noindent\textbf{Inductive case ($\ell = x \cons xs$):}
    $$\text{IH} = P(xs)$$
    $$\text{To show: } P(x \cons xs)$$
    \dots
  \end{proof}
\item Let's take a look at this in action.
  \begin{thm}
    For any lists $xs$, $ys$, and $zs$, $$xs \app (ys \app zs) = (xs \app ys) \app zs$$
  \end{thm}
  \begin{proof}
    By induction on $xs$.
    $$P(xs) = \forall ys, zs.\; xs \app (ys \app zs) = (xs \app ys) \app zs$$

    \noindent\textbf{Base case ($xs = \nil$):}
    $$\begin{array}{l@{=\langle} l@{\rangle}}
      \nil \app (ys \app zs) & \text{computation}\\
      ys \app zs & \text{computation}\\
      \multicolumn{2}{l}{(\nil \app ys) \app zs}
    \end{array}$$

    \noindent\textbf{Inductive case ($xs = x \cons xs'$):}
    $$
    \begin{array}{l@{=\langle}c@{\rangle}}
      (x \cons xs') \app (ys \app zs) & \text{computation}\\
      x \cons (xs' \app (ys \app zs)) & \text{IH}\\
      x \cons ((xs' \app ys) \app zs) & \text{computation}\\
      (x \cons (xs' \app ys)) \app zs & \text{computation}\\
      \multicolumn{2}{l}{((x \cons xs') \app ys) \app zs}
    \end{array}
    $$
  \end{proof}
\pagebreak
\item Now lets do it in Agda!
\begin{code}
++-assoc : âˆ€ {A : Set} (xs ys zs : List A) -> xs ++ (ys ++ zs) â‰¡ (xs ++ ys) ++ zs
++-assoc [] ys zs =
  begin
    [] ++ ys ++ zs
  â‰¡âŸ¨âŸ©
    ys ++ zs
  â‰¡âŸ¨âŸ©
    ([] ++ ys) ++ zs
  âˆŽ
++-assoc (x âˆ· xs) ys zs =
  begin
    (x âˆ· xs) ++ ys ++ zs
  â‰¡âŸ¨âŸ©
    x âˆ· (xs ++ ys ++ zs)
  â‰¡âŸ¨ cong (x âˆ·_) (++-assoc xs ys zs) âŸ©
    x âˆ· ((xs ++ ys) ++ zs)
  â‰¡âŸ¨âŸ©
    (x âˆ· (xs ++ ys)) ++ zs
  â‰¡âŸ¨âŸ©
    ((x âˆ· xs) ++ ys) ++ zs
  âˆŽ
\end{code}
\item More practice:
\begin{code}
++-identityË¡ : âˆ€ {A : Set} (xs : List A) -> [] ++ xs â‰¡ xs
++-identityË¡ xs = refl

++-identityÊ³ : âˆ€ {A : Set} (xs : List A) -> xs ++ [] â‰¡ xs
++-identityÊ³ [] = refl
++-identityÊ³ (x âˆ· xs) =
  begin
     (x âˆ· xs) ++ []
  â‰¡âŸ¨âŸ©
    x âˆ· (xs ++ [])
  â‰¡âŸ¨ cong (x âˆ·_) (++-identityÊ³ xs) âŸ©
    x âˆ· xs
  âˆŽ

++-length : âˆ€ {A : Set} (xs ys : List A) -> length (xs ++ ys) â‰¡ length xs + length ys
++-length [] ys = refl
++-length (x âˆ· xs) ys =
  begin
    length ((x âˆ· xs) ++ ys)
  â‰¡âŸ¨âŸ©
    length (x âˆ· (xs ++ ys))
  â‰¡âŸ¨âŸ©
    suc (length (xs ++ ys))
  â‰¡âŸ¨ cong suc (++-length xs ys) âŸ©
    suc (length xs + length ys)
  â‰¡âŸ¨âŸ©
    (suc (length xs)) + length ys
  â‰¡âŸ¨âŸ©
    length (x âˆ· xs) + length ys
  âˆŽ
\end{code}
\item Do the following as a class exercise:
\begin{code}
reverse-length : âˆ€ {A : Set} (xs : List A) -> length (reverse xs) â‰¡ length xs
reverse-length [] = refl
reverse-length (x âˆ· xs) =
  begin
    length (reverse (x âˆ· xs))
  â‰¡âŸ¨âŸ©
    length ((reverse xs) ++ [ x ])
  â‰¡âŸ¨ ++-length (reverse xs) [ x ] âŸ©
    (length (reverse xs)) + length [ x ]
  â‰¡âŸ¨âŸ©
    (length (reverse xs)) + 1
  â‰¡âŸ¨ cong (_+ 1) (reverse-length xs) âŸ©
    (length xs) + 1
  â‰¡âŸ¨ +-comm (length xs) 1 âŸ©
    1 + (length xs)
  â‰¡âŸ¨âŸ©
    suc (length xs)
  â‰¡âŸ¨âŸ©
    length (x âˆ· xs)
  âˆŽ
\end{code}

Now, turn it into a paper-and-pencil proof on the board.

\item We also have higher-order functions, just like in OCaml:
\begin{code}
map : âˆ€ {A B : Set} -> (A -> B) -> List A -> List B
map f [] = []
map f (x âˆ· xs) = (f x) âˆ· map f xs
    
foldr : âˆ€ {A B : Set} -> (A -> B -> B) -> B -> List A -> B
foldr _âŠ—_ e [] = e
foldr _âŠ—_ e (x âˆ· xs) = x âŠ— foldr _âŠ—_ e xs

mapâ€² : âˆ€ {A B : Set} -> (A -> B) -> List A -> List B
mapâ€² f = foldr (\ x ys -> f x âˆ· ys) [] 
\end{code}

\item We can use induction to reason about higher-order functions.
  For instance, we can show that the two versions of map above behave the same.

\begin{code}
mapâ€²-map : âˆ€ {A B : Set} (f : A -> B) (xs : List A) -> mapâ€² f xs â‰¡ map f xs
mapâ€²-map f [] = refl
mapâ€²-map f (x âˆ· xs) =
  begin
    mapâ€² f (x âˆ· xs)
  â‰¡âŸ¨âŸ©
    foldr (\ x ys -> f x âˆ· ys) [] (x âˆ· xs)
  â‰¡âŸ¨âŸ©
    f x âˆ· (foldr (\ x ys -> f x âˆ· ys) [] xs)
  â‰¡âŸ¨âŸ©
    f x âˆ· (mapâ€² f xs)
  â‰¡âŸ¨ cong (f x âˆ·_) (mapâ€²-map f xs) âŸ©
    f x âˆ· (map f xs)
  â‰¡âŸ¨âŸ©
    map f (x âˆ· xs)
  âˆŽ
\end{code}
\item Homework: turn this into a paper-and-pencil proof.

\item Again, lists have an \emph{induction principle} that the template is based on.
\begin{code}
list-ind : âˆ€ {A : Set} (P : List A -> Set) ->
  P [] ->
  (âˆ€ (x : A) (xs : List A) -> P xs -> P (x âˆ· xs)) ->
  âˆ€ (xs : List A) -> P xs
list-ind P Pnil Pcons [] = Pnil
list-ind P Pnil Pcons (x âˆ· xs) = Pcons x xs (list-ind P Pnil Pcons xs)
\end{code}

\end{itemize}

\section{Trees}

\begin{itemize}
\item Just like in OCaml, we can handle data structures that are not linear.
  For instance, we can write the type of binary trees:
\begin{code}
data Tree : Set -> Setâ‚ where
  Leaf : âˆ€ {A : Set} -> Tree A
  Node : âˆ€ {A : Set} -> Tree A -> A -> Tree A -> Tree A
\end{code}

\item We can program with trees just like we would in OCaml:
\begin{code}
size : âˆ€ {A : Set} -> Tree A -> â„•
size Leaf = 0
size (Node l _ r) = suc (size l + size r)

tree-rev : âˆ€ {A : Set} -> Tree A -> Tree A
tree-rev Leaf = Leaf
tree-rev (Node l x r) = Node (tree-rev r) x (tree-rev l)
\end{code}

\item Again, we can build a tree proof template.
  Ask them to build this as a stop and think.
\begin{thm}
  For every tree~$t$, $P(t)$.
\end{thm}
\begin{proof}
  By induction on $t$.
  $$P(t) = P(t)$$

  \noindent\textbf{Base case ($t = \textsf{Leaf}$):} \dots

  \noindent\textbf{Inductive case ($t = \textbf{Node}~l~x~r$):}
  $$\text{IH}_1 = P(l)$$
  $$\text{IH}_2 = P(r)$$
  $$\text{To Show: } P(\textbf{Node}~l~x~r)$$
  \dots
\end{proof}
\item Question: Why not have an inductive hypothesis for $x$?

\item We can then apply our proof template:
\begin{code}
tree-rev-size : âˆ€ {A : Set} (t : Tree A) -> size (tree-rev t) â‰¡ size t
tree-rev-size Leaf = refl
tree-rev-size (Node l x r) =
  begin
    size (tree-rev (Node l x r))
  â‰¡âŸ¨âŸ©
    size (Node (tree-rev r) x (tree-rev l))
  â‰¡âŸ¨âŸ©
    suc (size (tree-rev r) + size (tree-rev l))
  â‰¡âŸ¨ cong suc (cong (_+ size (tree-rev l)) (tree-rev-size r)) âŸ©
    suc (size r + size (tree-rev l))
  â‰¡âŸ¨ cong suc (cong (size r +_) (tree-rev-size l)) âŸ©
    suc (size r + size l)
  â‰¡âŸ¨ cong suc (+-comm (size r) (size l)) âŸ©
    suc (size l + size r)
  â‰¡âŸ¨âŸ©
    size (Node l x r)
  âˆŽ
\end{code}

\item Trees also have an induction principle:

\begin{code}
tree-ind : âˆ€ {A : Set} {P : Tree A -> Set} ->
  P Leaf ->
  (âˆ€ (x : A) {l r : Tree A} -> P l -> P r -> P (Node l x r)) ->
  âˆ€ (t : Tree A) -> P t
tree-ind Pleaf Pnode Leaf = Pleaf
tree-ind Pleaf Pnode (Node l x r) =
  Pnode x (tree-ind Pleaf Pnode l)
          (tree-ind Pleaf Pnode r)
\end{code}
  
\end{itemize}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-engine: luatex
%%% TeX-command-default: "Make"
%%% End:
